# 16-使用尾调用优化递归

递归函数是非常吃内存的，一个常见的例子是斐波那契数列的求解：

# 斐波那契数列

斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368........

这个数列从第3项开始，每一项都等于前两项之和。

通常我们可以使用递归函数求解：

```js
function fibSeq(n){
    if(n==1 || n==2){
        return 1;
    }
    return fibSeq(n-1)+fibSeq(n-2);
}
console.log(fibSeq(10));
```

调用这个函数，给的数值小一些，还没什么问题，像例子中求第100个斐波那契数列的值，就会久久的卡住不动，更大些还有可能造成堆栈溢出的错误。

因此，该如何优化递归调用呢？

------

##### 同学时间

##### 李想时间：

```js
function fbnq(n, x = 0, y = 1) {  
    if (n === 0) return x;
    return fbnq(n - 1, y, x + y)
  }

  console.log(fbnq(100));
```

##### MyColourfulLife时间

引出两点思考：

- 为什么普通的递归调用会那么消耗内存？
  - 函数调用会形成调用记录又称“调用帧”，用来保存函数的调用位置和内部变量信息，不断的递归调用会使调用帧越来越多。
- 什么是尾调用，尾调用的意义？
  - 尾调用是指某个函数的最后一步是调用另一个函数。
  - 尾调用每次执行完毕只有一个调用帧，大大节省了内存，永远不会造成内存溢出的错误。

------

ideal1985的写法就是尾调用，函数的最后一步是调用另一个函数，而最后调用的这个函数就是函数本身，这个称之为尾递归（同时满足尾调用和递归）。

#### 尾调用(Tail Call)

> 尾调用本身的概念非常简单，就是指某个函数的最后一步是调用另一个函数。

```js
function f(x){
  return g(x);
}
```

以下三种情况均不属于尾调用

```js
// 情况一 调用函数之后还有赋值操作
function f(x){
  let y = g(x);
  return y;
}

// 情况二 调用函数之后 又进行了一步运算
function f(x){
  return g(x) + 1;
}

// 情况三 没有return 表示最后一步是 return undefined
function f(x){
  g(x);
}
```

尾调用不一定要出现在函数尾部，只要是最后一步操作就可以。

```js
function f(x) {
  if (x > 0) {
    return m(x)
  }
  return n(x);
}
```

上述函数m和n都属于尾调用，因为他们都是函数f的最后一步操作。

#### 尾调用优化

尾调用之所以与其他调用不同，就是在于它特殊的调用位置。

> 函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。

```js
function f() {
  let m = 1;
  let n = 2;
  return g(m + n);
}
f();

// 等同于
function f() {
  return g(3);
}
f();

// 等同于
g(3);
```

上述代码中，g函数是尾调用。如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。

> 这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。

# 尾递归

函数调用自身，称为递归。如果尾调用自身，就称为尾递归。

递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。

往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。使用ES6的默认值，很方便做到这一点。

比如ideal1985的解答：

```js
function fbnq(n, x = 0, y = 1) {  
    if (n === 0) return x;
    return fbnq(n - 1, y, x + y)
  }

  console.log(fbnq(100));
```

------

*尾调用，就是在函数的返回值最后返回一个自身的函数，这样可以形成递归。**这样就不会形成一个stack overflow。*